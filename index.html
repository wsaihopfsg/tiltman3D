<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Gyro Pacman - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffeb3b; z-index: 10;
            text-align: center; padding: 20px;
        }
        button {
            padding: 15px 30px; font-size: 1.2rem; background: #ffeb3b; border: none;
            cursor: pointer; font-weight: bold; color: #000; border-radius: 5px; margin-top: 20px;
        }
        #score-board {
            position: absolute; top: 10px; left: 10px; color: white;
            font-size: 20px; z-index: 5; pointer-events: none;
        }
        #status-msg {
            position: absolute; top: 50px; left: 10px; color: #00ff00;
            font-size: 16px; z-index: 5; pointer-events: none; font-weight: bold;
        }
        #debug {
            position: absolute; bottom: 10px; left: 10px; color: #aaa;
            font-size: 12px; z-index: 5; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="score-board">Score: 0</div>
<div id="status-msg"></div>
<div id="debug">Tilt phone to move | Desktop: Arrow Keys</div>

<div id="overlay">
    <h1>3D Gyro Pacman</h1>
    <p>Tilt your phone to move.</p>
    <p>Eat pellets. Avoid red ghosts.</p>
    <button id="start-btn">START GAME</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- GAME CONSTANTS ---
    const WALL_SIZE = 10;
    const SPEED = 0.5;
    
    // --- GLOBAL VARIABLES ---
    let scene, camera, renderer;
    let pacman, ghosts = [], pellets = [], walls = [];
    let score = 0;
    let isPlaying = false;
    let velocity = { x: 0, z: 0 };
    
    // Safety Invincibility
    let isInvincible = false;
    let blinkInterval;
    
    // Audio Context
    let audioCtx;
    let bgmInterval;

    // Map Legend: 
    // 1 = Wall
    // 0 = Path + Pellet
    // 2 = Ghost Spawn (Top Corners)
    // 3 = Pacman Spawn (Bottom Center)
    // 9 = Empty Path (No pellet, good for spawn zones)
    const mapDesign = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,0,0,0,0,0,1,0,0,0,0,0,2,1], // Ghosts at [1,1] and [1,13]
        [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,1,0,1,0,1,1,0,1,0,1],
        [1,0,0,0,0,0,0,9,0,0,0,0,0,0,1],
        [1,1,1,0,1,0,1,0,1,0,1,0,1,1,1],
        [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
        [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,3,0,0,0,0,0,0,1], // Pacman at [9,7]
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Camera starts high but will snap to Pacman
        camera.position.set(0, 100, 100); 

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        buildLevel();

        window.addEventListener('resize', onWindowResize, false);
        
        // Desktop Fallback
        window.addEventListener('keydown', (e) => {
            if(!isPlaying) return;
            const speed = 15; 
            if(e.key === 'ArrowUp') handleMotion(0, -speed);
            if(e.key === 'ArrowDown') handleMotion(0, speed);
            if(e.key === 'ArrowLeft') handleMotion(speed, 0);
            if(e.key === 'ArrowRight') handleMotion(-speed, 0);
        });

        animate();
    }

    function buildLevel() {
        const wallGeo = new THREE.BoxGeometry(WALL_SIZE, WALL_SIZE, WALL_SIZE);
        const wallMat = new THREE.MeshLambertMaterial({ color: 0x1919A6 });
        
        const pelletGeo = new THREE.SphereGeometry(1.5, 8, 8);
        const pelletMat = new THREE.MeshBasicMaterial({ color: 0xffb8ae });

        const ghostGeo = new THREE.CylinderGeometry(3, 3, 8, 16);
        const ghostMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });

        const pacGeo = new THREE.SphereGeometry(4, 32, 32);
        const pacMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b, transparent: true, opacity: 1.0 });

        // Calculate offsets to center the map
        const offsetX = (mapDesign[0].length * WALL_SIZE) / 2;
        const offsetZ = (mapDesign.length * WALL_SIZE) / 2;

        for(let z = 0; z < mapDesign.length; z++) {
            for(let x = 0; x < mapDesign[z].length; x++) {
                const type = mapDesign[z][x];
                const posX = (x * WALL_SIZE) - offsetX;
                const posZ = (z * WALL_SIZE) - offsetZ;

                if (type === 1) { // Wall
                    const wall = new THREE.Mesh(wallGeo, wallMat);
                    wall.position.set(posX, WALL_SIZE/2, posZ);
                    scene.add(wall);
                    walls.push(new THREE.Box3().setFromObject(wall));
                } 
                else if (type === 0 || type === 2 || type === 3) {
                    // Place Pellet (unless it's empty space 9)
                    if(type === 0) {
                        const pellet = new THREE.Mesh(pelletGeo, pelletMat);
                        pellet.position.set(posX, 0, posZ);
                        scene.add(pellet);
                        pellets.push(pellet);
                    }

                    // Place Ghost
                    if (type === 2) {
                        const ghost = new THREE.Mesh(ghostGeo, ghostMat);
                        ghost.position.set(posX, 4, posZ);
                        // Randomize initial direction
                        ghost.userData = { dir: new THREE.Vector3(1,0,0), speed: 0.18 }; // Slightly slower than player
                        scene.add(ghost);
                        ghosts.push(ghost);
                    }

                    // Place Pacman
                    if (type === 3) {
                        pacman = new THREE.Mesh(pacGeo, pacMat);
                        pacman.position.set(posX, 4, posZ);
                        scene.add(pacman);
                    }
                }
            }
        }
    }

    // --- GAME LOGIC ---

    function handleOrientation(event) {
        if (!isPlaying) return;
        let gamma = event.gamma; // Left/Right
        let beta = event.beta;   // Front/Back
        
        // Calibration: Hold phone at 45 deg angle is "Neutral"
        beta = beta - 45; 

        handleMotion(gamma, beta);
    }

    function handleMotion(gamma, beta) {
        // Deadzone
        if (Math.abs(gamma) < 5) gamma = 0;
        if (Math.abs(beta) < 5) beta = 0;

        velocity.x = gamma * 0.01; 
        velocity.z = beta * 0.01; 
        
        velocity.x = Math.max(Math.min(velocity.x, SPEED), -SPEED);
        velocity.z = Math.max(Math.min(velocity.z, SPEED), -SPEED);
    }

    function checkCollision(position, radius) {
        const playerBox = new THREE.Box3();
        const min = new THREE.Vector3(position.x - radius, 0, position.z - radius);
        const max = new THREE.Vector3(position.x + radius, 10, position.z + radius);
        playerBox.set(min, max);

        for (let wallBox of walls) {
            if (playerBox.intersectsBox(wallBox)) {
                return true;
            }
        }
        return false;
    }

    function animate() {
        requestAnimationFrame(animate);

        if (isPlaying && pacman) {
            // 1. Move Pacman
            let nextPos = pacman.position.clone();
            nextPos.x += velocity.x;
            if (!checkCollision(nextPos, 3.5)) pacman.position.x = nextPos.x;

            nextPos = pacman.position.clone();
            nextPos.z += velocity.z;
            if (!checkCollision(nextPos, 3.5)) pacman.position.z = nextPos.z;
            
            // Rotation
            if (Math.abs(velocity.x) > 0.01 || Math.abs(velocity.z) > 0.01) {
                pacman.rotation.y = Math.atan2(-velocity.x, -velocity.z);
                pacman.rotation.z -= 0.1; 
            }

            // 2. Move Ghosts
            ghosts.forEach(ghost => {
                let gNext = ghost.position.clone().add(ghost.userData.dir.clone().multiplyScalar(ghost.userData.speed));
                
                if (checkCollision(gNext, 3)) {
                    // Change direction on wall hit
                    const dirs = [
                        new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                        new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
                    ];
                    ghost.userData.dir = dirs[Math.floor(Math.random()*dirs.length)];
                } else {
                    ghost.position.copy(gNext);
                }

                // Check Death
                if (ghost.position.distanceTo(pacman.position) < 6) {
                    if (!isInvincible) {
                        gameOver();
                    }
                }
            });

            // 3. Eat Pellets
            for (let i = pellets.length - 1; i >= 0; i--) {
                if (pacman.position.distanceTo(pellets[i].position) < 4) {
                    scene.remove(pellets[i]);
                    pellets.splice(i, 1);
                    score += 10;
                    document.getElementById('score-board').innerText = "Score: " + score;
                    playWakaSound();
                }
            }
            
            if (pellets.length === 0) {
                alert("YOU WIN!");
                isPlaying = false;
                window.location.reload();
            }

            // Camera Logic
            camera.position.x = pacman.position.x;
            camera.position.z = pacman.position.z + 60; 
            camera.lookAt(pacman.position);
        }

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function gameOver() {
        isPlaying = false;
        stopMusic();
        playDieSound();
        alert("GAME OVER! Score: " + score);
        window.location.reload();
    }

    // --- AUDIO SYSTEM ---
    function initAudio() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
    }

    function playWakaSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    function playDieSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(500, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
    }

    function startMusic() {
        if (!audioCtx) initAudio();
        let note = 0;
        const baseFreq = 100;
        const pattern = [1, 1, 1.5, 1.2]; 

        bgmInterval = setInterval(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            let freq = baseFreq * pattern[note % 4];
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
            note++;
        }, 500);
    }

    function stopMusic() {
        clearInterval(bgmInterval);
    }

    // --- GAME START / PERMISSION ---
    const startBtn = document.getElementById('start-btn');
    startBtn.addEventListener('click', async () => {
        initAudio();
        audioCtx.resume();
        
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') startGame();
                else alert('Permission needed to tilt-control!');
            } catch (e) {
                console.error(e);
                alert('Error requesting sensor permission');
            }
        } else {
            startGame();
        }
    });

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        isPlaying = true;
        
        // 1. Activate Invincibility
        isInvincible = true;
        const statusMsg = document.getElementById('status-msg');
        statusMsg.innerText = "SAFE MODE (3s)";
        
        // Blink visual
        blinkInterval = setInterval(() => {
            if (pacman) {
                pacman.material.opacity = pacman.material.opacity === 1 ? 0.3 : 1;
            }
        }, 200);

        // Turn off invincibility after 3 seconds
        setTimeout(() => {
            isInvincible = false;
            clearInterval(blinkInterval);
            if(pacman) pacman.material.opacity = 1;
            statusMsg.innerText = "";
        }, 3000);
        
        window.addEventListener('deviceorientation', handleOrientation);
        startMusic();
    }

    init();
</script>
</body>
</html>
