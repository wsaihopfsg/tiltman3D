<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Gyro Pacman</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffeb3b; z-index: 10;
            text-align: center; padding: 20px;
        }
        button {
            padding: 15px 30px; font-size: 1.2rem; background: #ffeb3b; border: none;
            cursor: pointer; font-weight: bold; color: #000; border-radius: 5px; margin-top: 20px;
        }
        #score-board {
            position: absolute; top: 10px; left: 10px; color: white;
            font-size: 20px; z-index: 5; pointer-events: none;
        }
        #debug {
            position: absolute; bottom: 10px; left: 10px; color: #aaa;
            font-size: 12px; z-index: 5; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="score-board">Score: 0</div>
<div id="debug">Tilt phone to move | Desktop: Arrow Keys</div>

<div id="overlay">
    <h1>3D Gyro Pacman</h1>
    <p>Tilt your phone to move.</p>
    <p>Eat pellets. Avoid red ghosts.</p>
    <button id="start-btn">START GAME</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- GAME CONSTANTS ---
    const WALL_SIZE = 10;
    const SPEED = 0.5;
    const MAP_SIZE = 15;
    
    // --- GLOBAL VARIABLES ---
    let scene, camera, renderer;
    let pacman, ghosts = [], pellets = [], walls = [];
    let score = 0;
    let isPlaying = false;
    let velocity = { x: 0, z: 0 };
    
    // Audio Context
    let audioCtx;
    let bgmInterval;

    // Simple Map Generation (1 = Wall, 0 = Path, 2 = Ghost Start)
    // 15x15 Grid
    const mapDesign = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
        [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
        [1,0,1,0,1,1,0,1,0,1,1,0,1,0,1],
        [1,0,0,0,0,0,0,2,0,0,0,0,0,0,1],
        [1,1,1,0,1,0,1,0,1,0,1,0,1,1,1],
        [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
        [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // --- INITIALIZATION ---
    function init() {
        // Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Camera (High angle perspective)
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 120, 80);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        // Build Level
        buildLevel();

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);
        
        // Keyboard fallback for desktop testing
        window.addEventListener('keydown', (e) => {
            if(!isPlaying) return;
            const speed = 15; // Simulated tilt
            if(e.key === 'ArrowUp') handleMotion(0, -speed);
            if(e.key === 'ArrowDown') handleMotion(0, speed);
            if(e.key === 'ArrowLeft') handleMotion(speed, 0);
            if(e.key === 'ArrowRight') handleMotion(-speed, 0);
        });

        // Loop
        animate();
    }

    function buildLevel() {
        const wallGeo = new THREE.BoxGeometry(WALL_SIZE, WALL_SIZE, WALL_SIZE);
        const wallMat = new THREE.MeshLambertMaterial({ color: 0x1919A6 }); // Arcade Blue
        
        const pelletGeo = new THREE.SphereGeometry(1.5, 8, 8);
        const pelletMat = new THREE.MeshBasicMaterial({ color: 0xffb8ae });

        const ghostGeo = new THREE.CylinderGeometry(3, 3, 8, 16);
        const ghostMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });

        // Center the map
        const offsetX = (mapDesign[0].length * WALL_SIZE) / 2;
        const offsetZ = (mapDesign.length * WALL_SIZE) / 2;

        for(let z = 0; z < mapDesign.length; z++) {
            for(let x = 0; x < mapDesign[z].length; x++) {
                const type = mapDesign[z][x];
                const posX = (x * WALL_SIZE) - offsetX;
                const posZ = (z * WALL_SIZE) - offsetZ;

                if (type === 1) {
                    // Wall
                    const wall = new THREE.Mesh(wallGeo, wallMat);
                    wall.position.set(posX, WALL_SIZE/2, posZ);
                    scene.add(wall);
                    walls.push(new THREE.Box3().setFromObject(wall));
                } else if (type === 0 || type === 2) {
                    // Pellet
                    const pellet = new THREE.Mesh(pelletGeo, pelletMat);
                    pellet.position.set(posX, 0, posZ);
                    scene.add(pellet);
                    pellets.push(pellet);
                    
                    if (type === 2) {
                        // Ghost
                        const ghost = new THREE.Mesh(ghostGeo, ghostMat);
                        ghost.position.set(posX, 4, posZ);
                        ghost.userData = { dir: new THREE.Vector3(1,0,0), speed: 0.2 };
                        scene.add(ghost);
                        ghosts.push(ghost);
                    }
                }
            }
        }

        // Create Pacman
        const pacGeo = new THREE.SphereGeometry(4, 32, 32);
        const pacMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
        pacman = new THREE.Mesh(pacGeo, pacMat);
        pacman.position.set(0, 4, 0); // Start center (ish)
        scene.add(pacman);
    }

    // --- GAME LOGIC ---

    // Handle Gyro Data
    // Gamma: Left/Right (-90 to 90)
    // Beta: Front/Back (-180 to 180)
    function handleOrientation(event) {
        if (!isPlaying) return;
        
        // Constrain values to avoid extreme speeds
        let gamma = event.gamma; // Left/Right
        let beta = event.beta;   // Front/Back
        
        // Normalize basic orientation for typical holding position (tilted up 45 deg)
        // Adjust beta so "flat" relative to user view is neutral
        beta = beta - 45; 

        handleMotion(gamma, beta);
    }

    function handleMotion(gamma, beta) {
        // Deadzone
        if (Math.abs(gamma) < 5) gamma = 0;
        if (Math.abs(beta) < 5) beta = 0;

        // Calculate velocity (x is left/right, z is up/down in ThreeJS)
        velocity.x = gamma * 0.01; 
        velocity.z = beta * 0.01; 
        
        // Cap max speed
        velocity.x = Math.max(Math.min(velocity.x, SPEED), -SPEED);
        velocity.z = Math.max(Math.min(velocity.z, SPEED), -SPEED);
    }

    function checkCollision(position, radius) {
        // Create a bounding box for the next position
        const playerBox = new THREE.Box3();
        const min = new THREE.Vector3(position.x - radius, 0, position.z - radius);
        const max = new THREE.Vector3(position.x + radius, 10, position.z + radius);
        playerBox.set(min, max);

        for (let wallBox of walls) {
            if (playerBox.intersectsBox(wallBox)) {
                return true;
            }
        }
        return false;
    }

    function animate() {
        requestAnimationFrame(animate);

        if (isPlaying && pacman) {
            // 1. Move Pacman X
            let nextPos = pacman.position.clone();
            nextPos.x += velocity.x;
            if (!checkCollision(nextPos, 3.5)) {
                pacman.position.x = nextPos.x;
            }

            // 2. Move Pacman Z
            nextPos = pacman.position.clone();
            nextPos.z += velocity.z;
            if (!checkCollision(nextPos, 3.5)) {
                pacman.position.z = nextPos.z;
            }
            
            // Rotate Pacman to face direction
            if (Math.abs(velocity.x) > 0.01 || Math.abs(velocity.z) > 0.01) {
                pacman.rotation.y = Math.atan2(-velocity.x, -velocity.z); // Face movement
                pacman.rotation.z -= 0.1; // Rolling effect
            }

            // 3. Move Ghosts (Simple AI: Random turns)
            ghosts.forEach(ghost => {
                let gNext = ghost.position.clone().add(ghost.userData.dir.clone().multiplyScalar(ghost.userData.speed));
                
                // Simple wall bounce
                if (checkCollision(gNext, 3)) {
                    // Pick random new direction (X or Z axis)
                    const dirs = [
                        new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                        new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
                    ];
                    ghost.userData.dir = dirs[Math.floor(Math.random()*dirs.length)];
                } else {
                    ghost.position.copy(gNext);
                }

                // Game Over Check
                if (ghost.position.distanceTo(pacman.position) < 6) {
                    gameOver();
                }
            });

            // 4. Eat Pellets
            for (let i = pellets.length - 1; i >= 0; i--) {
                if (pacman.position.distanceTo(pellets[i].position) < 4) {
                    scene.remove(pellets[i]);
                    pellets.splice(i, 1);
                    score += 10;
                    document.getElementById('score-board').innerText = "Score: " + score;
                    playWakaSound();
                }
            }
            
            // Win Condition
            if (pellets.length === 0) {
                alert("YOU WIN!");
                isPlaying = false;
                window.location.reload();
            }

            // Camera Follow
            camera.position.x = pacman.position.x;
            camera.position.z = pacman.position.z + 60; // Offset behind/above
            camera.lookAt(pacman.position);
        }

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function gameOver() {
        isPlaying = false;
        stopMusic();
        playDieSound();
        alert("GAME OVER! Score: " + score);
        window.location.reload();
    }

    // --- AUDIO SYSTEM (Procedural Synthesis) ---
    function initAudio() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
    }

    function playWakaSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    function playDieSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(500, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
    }

    function startMusic() {
        if (!audioCtx) initAudio();
        
        // Simple Bassline Loop
        let note = 0;
        const baseFreq = 100;
        const pattern = [1, 1, 1.5, 1.2]; // Frequency multipliers

        bgmInterval = setInterval(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            
            let freq = baseFreq * pattern[note % 4];
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
            note++;
        }, 500); // 120 BPM-ish
    }

    function stopMusic() {
        clearInterval(bgmInterval);
    }

    // --- GAME START / PERMISSION ---
    const startBtn = document.getElementById('start-btn');
    startBtn.addEventListener('click', async () => {
        // 1. Init Audio
        initAudio();
        audioCtx.resume();
        
        // 2. Request Gyro Permissions (iOS specific)
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') {
                    startGame();
                } else {
                    alert('Permission needed to tilt-control!');
                }
            } catch (e) {
                console.error(e);
                alert('Error requesting sensor permission');
            }
        } else {
            // Android or non-iOS 13+ devices
            startGame();
        }
    });

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        isPlaying = true;
        
        // Start Gyro listener
        window.addEventListener('deviceorientation', handleOrientation);
        
        // Start Music
        startMusic();
    }

    // Init ThreeJS scene immediately
    init();

</script>
</body>
</html>